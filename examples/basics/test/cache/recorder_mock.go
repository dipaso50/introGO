// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package cache

import (
	"sync"
)

// Ensure, that RecorderMock does implement Recorder.
// If this is not the case, regenerate this file with moq.
var _ Recorder = &RecorderMock{}

// RecorderMock is a mock implementation of Recorder.
//
// 	func TestSomethingThatUsesRecorder(t *testing.T) {
//
// 		// make and configure a mocked Recorder
// 		mockedRecorder := &RecorderMock{
// 			RegisterFunc: func(key string, tok interface{})  {
// 				panic("mock out the Register method")
// 			},
// 			RetreiveFunc: func(key string) (interface{}, bool) {
// 				panic("mock out the Retreive method")
// 			},
// 		}
//
// 		// use mockedRecorder in code that requires Recorder
// 		// and then make assertions.
//
// 	}
type RecorderMock struct {
	// RegisterFunc mocks the Register method.
	RegisterFunc func(key string, tok interface{})

	// RetreiveFunc mocks the Retreive method.
	RetreiveFunc func(key string) (interface{}, bool)

	// calls tracks calls to the methods.
	calls struct {
		// Register holds details about calls to the Register method.
		Register []struct {
			// Key is the key argument value.
			Key string
			// Tok is the tok argument value.
			Tok interface{}
		}
		// Retreive holds details about calls to the Retreive method.
		Retreive []struct {
			// Key is the key argument value.
			Key string
		}
	}
	lockRegister sync.RWMutex
	lockRetreive sync.RWMutex
}

// Register calls RegisterFunc.
func (mock *RecorderMock) Register(key string, tok interface{}) {
	if mock.RegisterFunc == nil {
		panic("RecorderMock.RegisterFunc: method is nil but Recorder.Register was just called")
	}
	callInfo := struct {
		Key string
		Tok interface{}
	}{
		Key: key,
		Tok: tok,
	}
	mock.lockRegister.Lock()
	mock.calls.Register = append(mock.calls.Register, callInfo)
	mock.lockRegister.Unlock()
	mock.RegisterFunc(key, tok)
}

// RegisterCalls gets all the calls that were made to Register.
// Check the length with:
//     len(mockedRecorder.RegisterCalls())
func (mock *RecorderMock) RegisterCalls() []struct {
	Key string
	Tok interface{}
} {
	var calls []struct {
		Key string
		Tok interface{}
	}
	mock.lockRegister.RLock()
	calls = mock.calls.Register
	mock.lockRegister.RUnlock()
	return calls
}

// Retreive calls RetreiveFunc.
func (mock *RecorderMock) Retreive(key string) (interface{}, bool) {
	if mock.RetreiveFunc == nil {
		panic("RecorderMock.RetreiveFunc: method is nil but Recorder.Retreive was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	mock.lockRetreive.Lock()
	mock.calls.Retreive = append(mock.calls.Retreive, callInfo)
	mock.lockRetreive.Unlock()
	return mock.RetreiveFunc(key)
}

// RetreiveCalls gets all the calls that were made to Retreive.
// Check the length with:
//     len(mockedRecorder.RetreiveCalls())
func (mock *RecorderMock) RetreiveCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	mock.lockRetreive.RLock()
	calls = mock.calls.Retreive
	mock.lockRetreive.RUnlock()
	return calls
}
